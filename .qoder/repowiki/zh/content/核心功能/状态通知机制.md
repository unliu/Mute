# 状态通知机制

<cite>
**本文档中引用的文件**   
- [Mute.swift](file://Mute/Classes/Mute.swift#L14-L210)
- [ViewController.swift](file://Example/Mute/ViewController.swift#L29-L33)
</cite>

## 目录
1. [状态通知机制概述](#状态通知机制概述)
2. [notify闭包设计与实现](#notify闭包设计与实现)
3. [alwaysNotify属性的作用](#alwaysnotify属性的作用)
4. [状态更新订阅示例](#状态更新订阅示例)
5. [内存泄漏风险与解决方案](#内存泄漏风险与解决方案)

## 状态通知机制概述

Mute库通过周期性播放静音音频文件并测量播放时长来检测设备的静音开关状态。其状态通知机制基于闭包回调实现，允许开发者订阅静音状态的变化。该机制的核心是`notify`闭包属性和`alwaysNotify`配置选项，它们共同决定了状态更新的触发条件和频率。

**Section sources**
- [Mute.swift](file://Mute/Classes/Mute.swift#L14-L210)

## notify闭包设计与实现

Mute库通过`notify`闭包属性实现状态变化通知。该闭包在每次静音检测完成后被调用，传递最新的静音状态。

```swift
public typealias MuteNotificationCompletion = ((_ mute: Bool) -> Void)
public var notify: MuteNotificationCompletion?
```

`notify`闭包在`soundFinishedPlaying()`方法中被调用，该方法是音频服务完成回调的处理函数：

```swift
private func soundFinishedPlaying() {
    self.isPlaying = false
    
    let elapsed = Date.timeIntervalSinceReferenceDate - self.interval
    let isMute = elapsed < 0.1
    
    if self.isMute != isMute || self.alwaysNotify {
        self.isMute = isMute
        DispatchQueue.main.async {
            self.notify?(isMute)
        }
    }
    self.schedulePlaySound()
}
```

当音频播放完成时，系统会计算播放耗时（`elapsed`），如果耗时小于0.1秒，则判定为静音状态。随后，如果状态发生变化或`alwaysNotify`为true，则通过`DispatchQueue.main.async`在主线程异步调用`notify`闭包，确保UI更新的安全性。

**Section sources**
- [Mute.swift](file://Mute/Classes/Mute.swift#L14-L210)

## alwaysNotify属性的作用

`alwaysNotify`属性控制着状态通知的触发策略，是Mute库灵活性的关键配置。

```swift
/// Should notify every second or only when changes?
/// True will notify every second of the state, false only when it changes
public var alwaysNotify = true
```

该属性具有两种工作模式：

- **alwaysNotify = true**：无论静音状态是否发生变化，都会在每次检测周期结束时通知。这种模式适用于需要持续监控静音状态的应用场景，如实时状态指示器。
- **alwaysNotify = false**：仅在静音状态发生改变时（从静音到非静音，或反之）才触发通知。这种模式适用于对状态变化敏感的场景，可以减少不必要的回调，提高效率。

通知条件的判断逻辑位于`soundFinishedPlaying()`方法中：
```swift
if self.isMute != isMute || self.alwaysNotify {
    // 触发通知
}
```

此逻辑确保了当状态变化或`alwaysNotify`启用时，都会执行通知回调。

**Section sources**
- [Mute.swift](file://Mute/Classes/Mute.swift#L25-L210)

## 状态更新订阅示例

以下示例展示了如何订阅Mute库的状态更新，并执行相应的UI刷新操作：

```swift
override func viewDidLoad() {
    super.viewDidLoad()

    // 设置检测间隔为2秒
    Mute.shared.checkInterval = 2.0

    // 启用持续通知
    Mute.shared.alwaysNotify = true

    // 订阅状态更新
    Mute.shared.notify = { [weak self] m in
        self?.label.text = m ? "静音" : "非静音"
    }

    // 5秒后暂停检测
    DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
        Mute.shared.isPaused = true
    }

    // 10秒后恢复检测
    DispatchQueue.main.asyncAfter(deadline: .now() + 10.0) {
        Mute.shared.isPaused = false
    }
}
```

在此示例中，开发者通过设置`notify`闭包来订阅状态更新。每当检测周期完成，闭包就会被调用，并根据最新的静音状态更新UILabel的文本。使用`[weak self]`捕获列表避免了潜在的内存泄漏。

**Section sources**
- [ViewController.swift](file://Example/Mute/ViewController.swift#L29-L33)

## 内存泄漏风险与解决方案

Mute库的状态通知机制存在潜在的内存泄漏风险，主要源于闭包对订阅对象的强引用。

### 潜在风险分析

当一个视图控制器或其他对象将`self`作为强引用捕获在`notify`闭包中时，会形成强引用循环：
- Mute.shared（单例）持有notify闭包
- notify闭包持有self（视图控制器）
- 视图控制器可能间接持有Mute.shared

这会导致视图控制器无法被释放，造成内存泄漏。

### 推荐解决方案

使用弱引用（weak reference）是解决此问题的标准方案：

```swift
Mute.shared.notify = { [weak self] m in
    self?.label.text = m ? "静音" : "非静音"
}
```

通过`[weak self]`捕获列表，闭包对`self`的引用变为弱引用，打破了强引用循环。当视图控制器被释放时，即使Mute.shared仍然存在，也不会阻止其内存回收。

此外，Mute类的析构函数也实现了适当的资源清理：
```swift
deinit {
    if self.soundId != 0 {
        AudioServicesRemoveSystemSoundCompletion(self.soundId)
        AudioServicesDisposeSystemSoundID(self.soundId)
    }
    NotificationCenter.default.removeObserver(self)
}
```

这确保了当Mute实例被销毁时，相关的音频服务和通知观察者都会被正确清理。

**Section sources**
- [Mute.swift](file://Mute/Classes/Mute.swift#L137-L145)
- [ViewController.swift](file://Example/Mute/ViewController.swift#L29)